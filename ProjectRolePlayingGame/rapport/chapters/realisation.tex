% !TeX root = ../main.tex
\chapter{Réalisation technique}

\section{Initialisation d'un test}
\paragraph{}
Afin de réaliser les tests, il faut tout d'abord ajouter à l'architecture Maven un répertoire test en parallèle du main, c'est dans ce répertoire que seront tous les tests effectués.
Ensuite choisir une classe à tester et si cette classe se trouve par exemple dans le package common et donc le chemin est \textit{"src/main/java/common/Variable.java"}, alors le chemin du test donnera \textit{"src/test/java/common/TestVariable.java"} créer une classe que l'on nomme par convention \textbf{NomTest.java} ou \textbf{TestNom.java}.

\paragraph{}
Pour utiliser JUnit, il est nécessaire de l'importer et tout se trouve dans le package \textbf{org.junit}. Par exemple pour faire un simple test il faut importer Test du package: \textbf{\textit{import org.junit.Test;}}.

\section{Réaliser un test}
\paragraph{}
Dans le but de tester une classe, JUnit dispose de plusieurs façons de procéder avec de nombreux \textbf{assert} adaptés à différentes situations.
Le cas le plus courant lors de ce projet est simplement de s'assurer de l'égalité entre ce qu'on a et ce qui est attendu. Dans ce cas, un \textbf{assertEquals(\textit{valeur attendue, valeur courante})} est ce qu'il y a de plus simple à utiliser. Le test échouera si les deux valeurs ne correspondent pas.

\paragraph{}
Exemple d'assert de JUnit :
\begin{itemize}
    \item assertNull(\textit{objet}) / assertNotNull(\textit{objet}) : Le test réussi si l'objet est \textit{null} / \textit{non null}
    \item assertEquals(\textit{valeur attendue, valeur courante}) / assertNotEquals(\textit{valeur attendue, valeur courante}) : Le test réussi si les valeurs correspondent / diffèrent
    \item assertTrue(\textit{déclaration}) / assertFalse(\textit{déclaration}) : Le test réussi si la déclaration est vraie / fausse
\end{itemize}
De plus, il est possible d'utiliser des assomptions afin de permettre à un test d'être ignoré si la condition n'a pas été remplie au préalable. De ce fait, pour tester un objet pour lequel une de ses valeurs doit être vraie, on peut utiliser une méthode comme suit :\label{assume}
Ici par exemple, le test \textbf{assertEquals} sera ignoré si, avant tout, \textit{person} n'est pas un employé. C'est après s'être assuré que \textit{person} est un employé qu'on peut tester si son revenu est correct.

\paragraph{}
Il y a également une autre manière de tester une fonction, si on est sûr que celle-ci lève une exception. On doit écrire : \textbf{@Test(expected = NullPointerException.class)}, si par exemple NullPointerException va être levée. Dans le corps de la fonction il suffit juste d'appeler ce qui doit lever l'exception.

\paragraph{}
À savoir que pour tout les \textit{assert} et \textit{assume}, il est possible de mettre une chaîne de caractère en ajoutant un argument au début des paramètres afin de faire passer un message à travers le test : \textbf{assertEquals(\textit{"message", valeur attendue, valeur courante})}

\paragraph{Hamcrest}
En plus d'avoir JUnit et ses assert à disposition pour tester les différentes classes de java, il existe un autre outil qui vient s'ajouter à JUnit. Il s'agit d'Hamcrest. Cet outil permet d'écrire des tests de façon plus verbose afin qu'ils soient plus lisible et plus explicite. Ainsi, pour tester par exemple qu'une valeur est égale à 18, avec JUnit cela aurait donné :
\begin{itemize}
    \item assertEquals(majeur, 18);
\end{itemize}
Alors qu'avec Hamcrest cela peut donner :
\begin{itemize}
    \item assertThat(majeur, equalTo(18));
    \item assertThat(majeur, is(equalTo(18)));
    \item assertThat(majeur, is(18));
\end{itemize}
\info{Remarque : ces trois déclarations sont équivalentes}
On peut constater que la seconde manière de procéder, en utilisant par exemple le décorateur \textbf{\textit{is}}, augmente de manière significative la lisibilité des tests en transformant les déclarations de sorte que celles-ci ressemblent à des phrases.

\section{Cas concret de tests}
\paragraph{}
À priori, de manière générale, une classe de test par classe concrète est recommandée. De ce fait, il nous faut prendre en compte le problème de quoi, comment et pourquoi tester. Des classes comme les Types sont plutôt simple à tester individuellement mais des classes comme Variable sont, au contraire, plus difficile à tester car elles peuvent prendre plusieurs paramètres. C'est pourquoi elles nécessitent plus de tests, à priori, au moins un par type.
C'est à ce moment que rentre en jeu les tests de classes paramétrées. Ils permettent, d'une manière pratique et rapide de pouvoir construire de nombreuses instances d'un objet avec des paramètres personnalisés.

\paragraph{}
Pour simplement tester une classe qui n'a comme construction qu'un objet Type par exemple, il suffit simplement de l'initialiser une fois et ensuite d'entâmer la panoplie de test sur cette instance. Par exemple, une classe TypeEntier dans laquelle il n'y aurait qu'un int, et ses \textit{getters/setters}, devrait pouvoir être testée sans mettre un million de valeur, mais plutôt de mettre un entier et voir que ça fonctionne et de mettre un autre type pour constater que ça échoue.
\paragraph{}
Tandis que pour le cas dans lequel il y a plusieurs paramètres à prendre en compte, il est nécessaire d'avoir le plus de paramètres différents au possible afin d'être consistent. Voici un exemple de test avec classe paramétrées :
Dans ce cas précis, on peut facilement se rendre compte de ce qu'on attend de la classe. On met la valeur à tester et le retour attendu dans les paramètres et lors du test on s'assure que le comportement est bien respecté et que les paramètres concordent.
